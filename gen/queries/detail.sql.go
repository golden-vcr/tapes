// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: detail.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const getTape = `-- name: GetTape :one
select
    tape.id,
    tape.title,
    tape.year,
    tape.runtime,
    tape.contributor_id,
    jsonb_agg(jsonb_build_object(
        'index', image.index,
        'color', image.color,
        'width', image.width,
        'height', image.height,
        'rotated', image.rotated
    ) order by image.index) as images,
    array(
        select tag_name
        from tapes.tape_to_tag
        where tape_to_tag.tape_id = tape.id
        order by tag_name
    )::text[] as tags
from tapes.tape
join tapes.image on image.tape_id = tape.id
where tape.id = $1
group by tape.id
order by tape.id
`

type GetTapeRow struct {
	ID            int32
	Title         string
	Year          sql.NullInt32
	Runtime       sql.NullInt32
	ContributorID sql.NullString
	Images        json.RawMessage
	Tags          []string
}

func (q *Queries) GetTape(ctx context.Context, tapeID int32) (GetTapeRow, error) {
	row := q.db.QueryRowContext(ctx, getTape, tapeID)
	var i GetTapeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Year,
		&i.Runtime,
		&i.ContributorID,
		&i.Images,
		pq.Array(&i.Tags),
	)
	return i, err
}

const getTapeContributorIds = `-- name: GetTapeContributorIds :many
select
    distinct tape.contributor_id::text
from tapes.tape
where tape.contributor_id is not null
`

func (q *Queries) GetTapeContributorIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTapeContributorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tape_contributor_id string
		if err := rows.Scan(&tape_contributor_id); err != nil {
			return nil, err
		}
		items = append(items, tape_contributor_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTapes = `-- name: GetTapes :many
select
    tape.id,
    tape.title,
    tape.year,
    tape.runtime,
    tape.contributor_id,
    jsonb_agg(jsonb_build_object(
        'index', image.index,
        'color', image.color,
        'width', image.width,
        'height', image.height,
        'rotated', image.rotated
    ) order by image.index) as images,
    array(
        select tag_name
        from tapes.tape_to_tag
        where tape_to_tag.tape_id = tape.id
        order by tag_name
    )::text[] as tags
from tapes.tape
join tapes.image on image.tape_id = tape.id
group by tape.id
order by tape.id
`

type GetTapesRow struct {
	ID            int32
	Title         string
	Year          sql.NullInt32
	Runtime       sql.NullInt32
	ContributorID sql.NullString
	Images        json.RawMessage
	Tags          []string
}

func (q *Queries) GetTapes(ctx context.Context) ([]GetTapesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTapes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTapesRow
	for rows.Next() {
		var i GetTapesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Year,
			&i.Runtime,
			&i.ContributorID,
			&i.Images,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
